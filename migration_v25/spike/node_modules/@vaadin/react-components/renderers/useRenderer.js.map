{
  "version": 3,
  "sources": ["../src/renderers/useRenderer.ts"],
  "sourcesContent": ["import {\n  type ComponentType,\n  createElement,\n  type PropsWithChildren,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useReducer,\n} from 'react';\nimport { createPortal, flushSync } from 'react-dom';\nimport type { Slice, WebComponentRenderer } from './renderer.js';\nimport { flushMicrotask } from '../utils/flushMicrotask.js';\n\nexport type UseRendererResult<W extends WebComponentRenderer> = readonly [\n  portals?: ReadonlyArray<ReactElement | null>,\n  renderer?: W,\n];\n\nconst initialState = new Map();\n\nfunction rendererReducer<W extends WebComponentRenderer>(\n  state: Map<HTMLElement, Slice<Parameters<W>, 1>>,\n  [root, ...args]: Parameters<W>,\n): Map<HTMLElement, Slice<Parameters<W>, 1>> {\n  return new Map(state).set(root, args as Slice<Parameters<W>, 1>);\n}\n\nexport type RendererConfig<W extends WebComponentRenderer> = {\n  renderMode?: 'default' | 'sync' | 'microtask';\n  shouldRenderPortal?(root: HTMLElement, ...args: Slice<Parameters<W>, 1>): boolean;\n};\n\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  node: ReactNode,\n  convert?: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig<W>,\n): UseRendererResult<W>;\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  reactRenderer: ComponentType<P> | null | undefined,\n  convert: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig<W>,\n): UseRendererResult<W>;\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  reactRendererOrNode: ReactNode | ComponentType<P> | null | undefined,\n  convert?: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig<W>,\n): UseRendererResult<W> {\n  const [map, update] = useReducer(rendererReducer, initialState);\n  const renderer = useCallback(\n    ((...args: Parameters<W>) => {\n      if (config?.renderMode === 'microtask') {\n        flushMicrotask(() => update(args));\n      } else if (config?.renderMode === 'sync') {\n        flushSync(() => update(args));\n      } else {\n        update(args);\n      }\n    }) as W,\n    [],\n  );\n\n  return reactRendererOrNode\n    ? [\n        Array.from(map.entries())\n          .filter(([root, args]) => {\n            return config?.shouldRenderPortal?.(root, ...args) ?? true;\n          })\n          .map(([root, args]) =>\n            createPortal(\n              convert\n                ? createElement<P>(reactRendererOrNode as ComponentType<P>, convert(args))\n                : (reactRendererOrNode as ReactNode),\n              root,\n            ),\n          ),\n        renderer,\n      ]\n    : [];\n}\n"],
  "mappings": "AAAA,OAEE,iBAAAA,EAIA,eAAAC,EACA,cAAAC,MACK,QACP,OAAS,gBAAAC,EAAc,aAAAC,MAAiB,YAExC,OAAS,kBAAAC,MAAsB,6BAO/B,MAAMC,EAAe,IAAI,IAEzB,SAASC,EACPC,EACA,CAACC,EAAM,GAAGC,CAAI,EAC6B,CAC3C,OAAO,IAAI,IAAIF,CAAK,EAAE,IAAIC,EAAMC,CAA+B,CACjE,CAiBO,SAASC,EACdC,EACAC,EACAC,EACsB,CACtB,KAAM,CAACC,EAAKC,CAAM,EAAId,EAAWK,EAAiBD,CAAY,EACxDW,EAAWhB,EACd,IAAIS,IAAwB,CACvBI,GAAQ,aAAe,YACzBT,EAAe,IAAMW,EAAON,CAAI,CAAC,EACxBI,GAAQ,aAAe,OAChCV,EAAU,IAAMY,EAAON,CAAI,CAAC,EAE5BM,EAAON,CAAI,CAEf,EACA,CAAC,CACH,EAEA,OAAOE,EACH,CACE,MAAM,KAAKG,EAAI,QAAQ,CAAC,EACrB,OAAO,CAAC,CAACN,EAAMC,CAAI,IACXI,GAAQ,qBAAqBL,EAAM,GAAGC,CAAI,GAAK,EACvD,EACA,IAAI,CAAC,CAACD,EAAMC,CAAI,IACfP,EACEU,EACIb,EAAiBY,EAAyCC,EAAQH,CAAI,CAAC,EACtEE,EACLH,CACF,CACF,EACFQ,CACF,EACA,CAAC,CACP",
  "names": ["createElement", "useCallback", "useReducer", "createPortal", "flushSync", "flushMicrotask", "initialState", "rendererReducer", "state", "root", "args", "useRenderer", "reactRendererOrNode", "convert", "config", "map", "update", "renderer"]
}

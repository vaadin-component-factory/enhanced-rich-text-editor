# Phase 5.0: Public API Breaking Changes Audit — Plan

## Ziel

Alle Breaking Changes zwischen ERTE V24 und V25 identifizieren und für **jeden einzelnen** bewerten:
1. **Was** hat sich geändert? (V24-Signatur → V25-Signatur)
2. **Warum** wurde die Änderung gemacht?
3. **Notwendig?** — Erzwungen durch Vaadin 25 / Jackson 3 / Quill 2 / Parchment 3? Oder unnötige Optimierung/Vereinfachung während der Migration?
4. **Rollback möglich?** — Kann die V24-API wiederhergestellt werden, ohne andere V25-Funktionalität zu beeinträchtigen?

**Ziel ist es, unnötige Breaking Changes zu finden und rückgängig zu machen**, damit der Upgrade-Pfad für bestehende ERTE-Nutzer so reibungslos wie möglich ist.

Dokumentations-Anpassungen (Upgrade Guide etc.) erfolgen NACH dieser Analyse und nach eventuellen API-Rollbacks — nicht als Teil von 5.0.

---

## Scope

### Was wird geprüft

| Bereich | V24 Quellen | V25 Quellen |
|---------|-------------|-------------|
| **Java Core** | `enhanced-rich-text-editor/src/main/java/` | `enhanced-rich-text-editor-v25/src/main/java/` |
| **Java Tables** | `enhanced-rich-text-editor-tables/src/main/java/` | `enhanced-rich-text-editor-tables-v25/src/main/java/` |
| **JavaScript** | `enhanced-rich-text-editor/src/main/resources/META-INF/resources/frontend/` | `enhanced-rich-text-editor-v25/src/main/resources/META-INF/resources/frontend/` |
| **CSS Custom Properties** | V24 custom properties (aus Doku/Code) | V25 custom properties (aus `--vaadin-erte-*`) |

### Was wird NICHT geprüft
- Private/interne API-Änderungen (package-private, private Methoden)
- Test-Klassen
- Demo-Code
- Rein additive neue APIs (nur breaking/geänderte/entfernte)

---

## Kategorien für Breaking Changes

| Kategorie | Bedeutung | Beispiel |
|-----------|-----------|----------|
| **NECESSARY — Platform** | Vaadin 25 erzwingt die Änderung | `elemental.json.JsonObject` → `tools.jackson` (Jackson 3 in Vaadin 25) |
| **NECESSARY — Quill 2** | Quill 2 / Parchment 3 erzwingt die Änderung | Delta-Format, Blot-API-Änderungen |
| **NECESSARY — Architecture** | V25-Architekturentscheidung (RteExtensionBase, HTML-primary) erzwingt es | `getValue()` liefert HTML statt Delta |
| **NECESSARY — Bugfix** | Tippfehler-Korrekturen, Security-Fixes | `setPlacehoderAltAppearance` → `setPlaceholderAltAppearance` |
| **UNNECESSARY — Optimization** | Methode/Klasse entfernt als "Vereinfachung", ohne dass Vaadin 25 es erfordert | TemplateParser-Methoden entfernt |
| **UNNECESSARY — Oversight** | Versehentlich nicht migriert / vergessen | Konstruktor fehlt, der leicht umsetzbar wäre |

---

## Methode

### Schritt 1: Systematische Inventur

Für jede V24-Klasse mit public/protected API:

1. **Alle public/protected Methoden, Konstruktoren, Enums, Inner Classes** auflisten
2. **V25-Gegenstück finden** (oder feststellen, dass es keins gibt)
3. **Für jede Abweichung** dokumentieren: was, warum, notwendig, rollback-möglich

Die Inventur umfasst:

**Java Core:**
- `EnhancedRichTextEditor.java` (V24 vs V25)
- `GeneratedEnhancedRichTextEditor.java` (V24, existiert in V25 nicht — alle dort definierten public APIs prüfen)
- `Placeholder.java` (V24 vs V25)
- `EnhancedRichTextEditorVariant.java` (V24, existiert in V25 nicht)
- `TabConverter.java` (V24, existiert in V25 nicht)
- Alle Event-Klassen (Inner Classes in V24 Generated vs V25 ERTE)
- `ToolbarButton` enum (V24 vs V25)
- `ToolbarSlot` enum (V24 vs V25)
- I18n-Klasse (V24 inner class vs V25 separate Klasse)

**Java Tables:**
- `EnhancedRichTextEditorTables.java` (V24 vs V25)
- `TableTemplate.java`, `ColumnDefinition.java` (V24 vs V25)
- `TemplateParser.java` (V24 vs V25 — bekanntes Beispiel für unnötige Entfernung)
- Alle Tables-Event-Klassen
- Tables I18n-Klasse

**JavaScript (public API):**
- Custom Events, die von Java `@DomEvent` gehört werden
- Öffentliche JS-Methoden, die von Java `executeJs()` aufgerufen werden
- Web Component Properties (`@property`)
- Registrierter Tag-Name

**CSS/Styles:**
- Custom Properties (`--vaadin-erte-*`, `--vaadin-erte-tables-*`)
- Part-Namen für `::part()` Styling
- CSS-Klassen in `.ql-editor` (für externes Styling)

### Schritt 2: Bewertung

Für jeden identifizierten Breaking Change:
- Recherche im Git-Log: Wann/warum wurde die Änderung gemacht?
- Prüfung: Gibt es eine technische Notwendigkeit in V25?
- Wenn UNNECESSARY: Aufwand für Rollback einschätzen (einfach / aufwändig / unmöglich)

### Schritt 3: Ergebnis-Dokument

Vollständige Liste im Progress-File `5.0_api_breaking_changes_audit.md`:
- Tabelle pro Klasse/Bereich
- Jede Zeile: V24 Signatur | V25 Status | Kategorie | Rollback-Empfehlung
- Zusammenfassung: Wie viele notwendig, wie viele unnötig, Rollback-Aufwand

---

## Agent-Einsatz

**architecture-guard** (Hauptarbeit):
- Systematischer V24↔V25 API-Vergleich
- Alle Java-Dateien, alle public/protected Members
- Ergebnis: Vollständige Diff-Liste

**Orchestrator** (Konsolidierung):
- Agent-Ergebnis durchgehen
- Für jeden Change: Git-History prüfen, Notwendigkeit bewerten
- Finale Liste mit Rollback-Empfehlungen erstellen

---

## Komplexitätsempfehlung

**Hybrid.** Die systematische Inventur (Schritt 1) wird an `architecture-guard` delegiert. Die Bewertung (Schritt 2) erfordert Kontext über die Migrationsentscheidungen und wird vom Orchestrator durchgeführt.

---

## Bekanntes Beispiel: TemplateParser

In V24 hat `TemplateParser` Methoden wie `parseTemplateString(String)`, die von externem Code genutzt werden könnten. Während der V25-Migration wurden einige davon als "unnötige Vereinfachung" entfernt. Dies ist ein klassisches Beispiel für einen vermeidbaren Breaking Change — die Methoden hätten beibehalten werden können, da Jackson 3 die gleiche Funktionalität ermöglicht.

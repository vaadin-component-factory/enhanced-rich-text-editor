# Phase 3.1c: Tabstops + Rulers + Soft-Break (Features 1, 2, 3)

## Status: COMPLETE

## Feature Summary
Tab key inserts TabBlot embed. Tab width calculated iteratively from defined tabstop positions.
L/R/M alignment. Horizontal ruler with clickable tabstop markers. Soft-break (Shift+Enter)
copies tabs up to cursor position. Java API: `TabStop` class, `setTabStops()`, `setNoRulers()`.

## Dependencies
- Phase 3.1a (Custom Slots) — toolbar infrastructure
- Phase 3.1b (Readonly) — sanitizer infrastructure (class whitelist)

## Implementation Summary

### JS (`vcf-enhanced-rich-text-editor.js`)
- **TabBlot**: Quill 2 Embed, `<span class="ql-tab">`, mousedown handler for smart cursor placement
- **SoftBreakBlot**: Quill 2 Embed, `<br>` content element
- **Tab width engine**: 9 methods ported from V24 (`_updateTabWidths`, `_requestTabUpdate`, `_measureContentWidth`, etc.)
- **Keyboard bindings**: Tab (insert + sync setSelection), Shift+Enter (soft-break with tab copying limited by tabstop count), Shift+Tab (focus toolbar), Enter (tab update passthrough)
- **Ruler DOM**: `_injectRuler()` creates ruler with direction-based tabstop icons, click to add, click marker to cycle L→R→M→remove
- **CSS**: `.ql-tab` (inline-flex with guard nodes), `.ql-soft-break` (inline), ruler styles
- **Properties**: `tabStops` (Array), `noRulers` (Boolean, reflect)

### Java
- **`TabStop.java`**: Immutable value object with `Direction` enum (LEFT, RIGHT, MIDDLE)
- **`EnhancedRichTextEditor.java`**: `setTabStops()`, `getTabStops()`, `setNoRulers()`, `isNoRulers()` using Jackson 3
- **`RteExtensionBase.java`**: Sanitizer updated with `ql-tab`, `ql-soft-break` in ALLOWED_ERTE_CLASSES
- **`ErteTabStopTestView.java`**: Route `erte-test/tabstops`, 3 tabstops (L@150, R@350, M@550)

### Test Results
- **64 passed**, 11 skipped (9 whitespace indicators → Phase 3.3b, 2 formatted text → Quill 2 limitation)
- Regression: readonly 17 pass + 1 fixme, toolbar 19 pass + 5 future

## Key Learnings
1. **Embed outer node must NOT have `contenteditable="false"`** — Quill 2 guard nodes (`\uFEFF`) are INSIDE the embed domNode. Setting contenteditable on outer node makes guard nodes non-editable, breaking cursor placement.
2. **setSelection after insertEmbed must be SYNCHRONOUS with `Quill.sources.USER`** — `Promise.resolve()` + API/SILENT leaves cursor in guard node context.
3. **Ruler injection must happen BEFORE property observers** — otherwise initial tabstop rendering finds no ruler DOM.
4. **Format toggles (Ctrl+B/I) don't work at embed boundary** — Quill 2 guard-node limitation, not ERTE bug. Marked as fixme.

## Regression Issues (identified 2026-02-19)

Two regression bugs were identified after Phase 3.1c completion. Root cause analysis
was performed by three independent agents (fullstack-developer, ui-designer, agents-manager).
**Consensus: no architectural rewrite needed** — the Embed-based TabBlot approach is correct
for Quill 2. The problems are CSS/layout issues, not structural deficiencies.

### Bug 1: Cursor invisible at certain tab positions

**Symptoms:**
- After inserting 1 tab: cursor NOT visible
- After inserting 2 tabs: cursor NOT visible
- After inserting 3 tabs: cursor IS visible (after the 3rd tab)
- Cursor at line start (before tabs) IS always visible
- Critical clue: first tab 134px wide → invisible. Manual 131px/133px → visible. 132px → invisible.
  Pattern does NOT hold for other tabs (not simply even/odd).

**Root Cause (confirmed by both agents):**
Quill 2 Embed constructor creates guard TextNodes (`\uFEFF`) as direct children of `.ql-tab`.
With `display: inline-flex`, these TextNodes become **anonymous flex items** per CSS Flexbox
Level 1, Section 4 ("Flex Items"). Since `\uFEFF` has zero glyph advance width and `flex: 1`
on contentNode takes all space, guard anonymous flex items get **exactly 0px width**. Chrome's
caret rendering engine cannot reliably position a 1px cursor inside a 0px-wide anonymous flex
item — the degenerate box geometry at the compositor rasterization stage produces an
unpredictable caret position. Visibility depends on the cumulative sub-pixel offsets of
preceding flex items and the browser's rounding strategy (floor/round/ceil per device pixel),
which varies with GPU driver and DPR (device pixel ratio). On 2x displays, the bug may
manifest differently or not at all. **Bug is primarily Chrome/Blink-specific** — Firefox
uses a separate caret-painting path that is less sensitive to 0px anonymous flex items.

**Quill 2 Embed DOM structure** (auto-created by Embed constructor, NOT modifiable):
```html
<span class="ql-tab" style="width: 134px">
  TextNode("\uFEFF")                     ← leftGuard (anonymous flex item, 0px)
  <span contenteditable="false"></span>  ← contentNode (flex: 1, takes all space)
  TextNode("\uFEFF")                     ← rightGuard (anonymous flex item, 0px)
</span>
```

**Aggravating CSS factors — DO NOT USE any of these on `.ql-tab`:**
- `will-change: width` + `transform: translateZ(0)` → compositor layer promotion, caret rendering
  across compositor boundaries is fragile in Chrome with GPU compositing
- `overflow: clip` + `height: 1rem` → clips 26px caret (Lumo line-height 1.625) to 16px box
- `overflow: hidden` → creates BFC that isolates caret entirely
- `height: 1rem` (explicit) → constrains caret containing block, causes baseline alignment issues
- `line-height: 1rem` (explicit) → overrides paragraph line-height, creates "jumping caret height"
  when arrow-keying past tabs (Lumo uses `line-height: 1.625`)
- `font-size: 0` on OUTER `.ql-tab` → (V24 pattern, incompatible with Quill 2) makes guard
  TextNodes render in 0px font context, compounds degenerate box geometry

**Golden rule:** `.ql-tab` MUST NOT set explicit `height` or `line-height` — Lumo's
line-height varies and the caret must match the paragraph context.

**Previous fix attempt (uncommitted):** Changed to `overflow: visible`, removed `height`/
`line-height`/`will-change`/`transform`. Improvements, but does NOT fix the core 0px anonymous
flex item problem.

#### Fix Variant A: Guard-Node Wrapping (UI-Designer approach) — RECOMMENDED PRIMARY

Wrap guard TextNodes in named `<span class="ql-tab-guard">` elements in the TabBlot
**constructor** (after `super()` which creates the guards). This transforms anonymous
flex items into named flex items with proper inline formatting context for caret rendering.

**Why constructor, not `static create()`:** Quill 2 lifecycle is `static create()` →
returns DOM node → `constructor(scroll, node)` adds guards. Guards don't exist at
`create()` time.

**Key insight:** Wrapping reparents the TextNode but preserves object identity.
Quill's internal methods are safe because:
- `index()` — uses `node === this.leftGuard` identity check → preserved (same TextNode object)
- `restore()` — operates on Parchment's **blot tree** (`this.parent`, `this.prev`, `this.next`),
  NOT on DOM `parentNode`. Guard's DOM parent changes but blot-tree parent stays the same.
- `update()` — receives MutationRecords where `mutation.target` for `characterData` mutations
  is the TextNode itself (not its parent). MutationObserver follows the node, not its DOM position.
- `setNativeRange()` call chain: `setSelection()` → `setRange()` → `setNativeRange()` →
  `blot.position()` → `Range.setStart()/setEnd()`. Works regardless of guard wrapping.

**Sanitizer note:** `ql-tab-guard` does NOT need to be added to the sanitizer whitelist.
These wrapper elements are runtime-only — they are created by the TabBlot constructor on
every instantiation and are never present in serialized HTML or delta.

**Implementation:**

JS — TabBlot constructor addition:
```javascript
class TabBlot extends Embed {
  // ... existing static fields and create() ...

  constructor(scroll, node) {
    super(scroll, node);
    this._wrapGuardNodes();
  }

  _wrapGuardNodes() {
    if (this.leftGuard?.nodeType === Node.TEXT_NODE &&
        this.leftGuard.parentNode === this.domNode) {
      const w = document.createElement('span');
      w.className = 'ql-tab-guard';
      this.domNode.insertBefore(w, this.leftGuard);
      w.appendChild(this.leftGuard); // reparents, same TextNode object
    }
    if (this.rightGuard?.nodeType === Node.TEXT_NODE &&
        this.rightGuard.parentNode === this.domNode) {
      const w = document.createElement('span');
      w.className = 'ql-tab-guard';
      // Use insertBefore (not appendChild) for robustness if other nodes exist
      this.domNode.insertBefore(w, this.rightGuard);
      w.appendChild(this.rightGuard); // reparents, same TextNode object
    }
  }

  // ... rest of TabBlot unchanged ...
}
```

CSS — new rules + **REPLACE existing `.ql-tab > span`** (the old selector is too broad
and would also match `.ql-tab-guard` spans, applying `flex: 1; font-size: 0` to guards):
```css
.ql-tab {
  display: inline-flex;
  min-width: 2px;
  white-space: pre;
  vertical-align: baseline;
  position: relative;
  overflow: visible;
  cursor: default;
  user-select: none;
  -webkit-user-select: none;
  /* NO height, line-height, will-change, transform — see golden rule above */
}
.ql-tab-guard {
  flex: 0 0 2px;
  min-width: 2px;
  font-size: inherit;
  line-height: inherit;
  pointer-events: none;
}
.ql-tab > span[contenteditable="false"] {
  flex: 1 1 0px;
  min-width: 0;
  font-size: 0;
  line-height: 0;
  overflow: hidden;
}
```

**CSS notes:**
- `cursor: default` — tab has a smart mousedown handler (left/right half placement), I-beam is misleading
- `user-select: none` — prevents selection artifacts inside the flex container with `overflow: visible`
- `pointer-events: none` on guards — defensive, prevents guard spans from intercepting mouse events
- **Guard min-width 2px is critical:** Without explicit sizing, the `\uFEFF` glyph has zero advance
  width → guard spans collapse to 0px → Chrome still can't render caret. Confirmed: 0px = invisible
  caret, 1px = visible, 2px = more reliable across DPR/zoom levels. At 110% browser zoom, 0px guards
  become visible (sub-pixel math changes) — confirming this is a rendering threshold issue.
  Total overhead: 2×2px = 4px per tab, imperceptible at typical 100-200px tab widths.
- **The existing `.ql-tab > span` rule MUST be replaced** with `.ql-tab > span[contenteditable="false"]`.
  Assumption: Quill 2 Embed always sets `contenteditable="false"` on contentNode.
- `flex: 1 1 0px` (not `flex: 1`) — explicit flex-basis `0px` for spec correctness

**Shadow DOM note:** Styles are in `static get styles()`, scoped to the component's shadow DOM.
Host apps cannot style `.ql-tab` via `::part()` — parts would need to be explicitly exported
if host-app tab customization is ever needed.

**RTL note:** Current tab layout assumes LTR. Quill 2 does not natively support RTL well.
Guard wrapping places leftGuard first in DOM order — in RTL this would swap visually but
Quill's logical model stays LTR. Known limitation, not a regression.

**Compatibility risk:** Code that checks `this.leftGuard.parentNode === this.domNode` would
break (now it's the wrapper span). Needs testing with: typing before/after tabs, arrow key
navigation, selection across tabs, copy/paste, undo/redo, `restore()` cycle.
Also test: Quill's `optimize()` scroll cleanup passes — ensure they don't strip wrapper
spans as "unknown" DOM inside embeds (unlikely but should verify).

#### Fix Variant B: `position()` Override (Fullstack-Developer approach) — BACKUP

Override Parchment's `LeafBlot.position()` in TabBlot to return guard TextNode references
directly instead of `[parentNode, childIndex]`. This gives the browser a text-node anchor
for caret rendering, bypassing the anonymous flex item geometry problem.

**Background:** Parchment's default `LeafBlot.position()` returns:
```javascript
// [parentNode, childOffset] — browser anchors caret at parent level
const childNodes = Array.from(this.parent.domNode.childNodes);
let offset = childNodes.indexOf(this.domNode);
if (index > 0) offset += 1;
return [this.parent.domNode, offset];
```

This places the Selection at PARENT level. For an `inline-flex` element, the browser
treats the entire container as a single unit → caret at left or right edge, subject
to the 0px anonymous flex item problem.

**Implementation:**
```javascript
class TabBlot extends Embed {
  // ... existing code ...

  position(index, _inclusive) {
    if (index <= 0) {
      return [this.leftGuard, 1]; // after the \uFEFF char in leftGuard
    }
    return [this.rightGuard, this.rightGuard.data.length]; // after \uFEFF in rightGuard
  }
}
```

**CSS requirements for Variant B:** Same `.ql-tab` base CSS as Variant A (no `height`,
`line-height`, `will-change`, `transform`; use `overflow: visible`, `cursor: default`,
`user-select: none`). Does NOT require `.ql-tab-guard` rule or contentNode selector change.
The existing `.ql-tab > span` selector can remain since no guard wrapping is done.

**Compatibility risk:** Quill's selection normalization may expect `position()` to return
`[parent, childIndex]` for embeds. Could cause issues with: range calculations across
multiple embeds, `getSelection()` returning unexpected ranges, `formatText()` on ranges
containing tabs. Needs thorough testing.

**Advantage over Variant A:** No DOM modification — less invasive, lower risk of breaking
Quill internals. Works within the existing layout model.

**Disadvantage:** Doesn't fix the LAYOUT problem, only the CARET PLACEMENT. Guard nodes
remain 0px anonymous flex items. `getBoundingClientRect()` on guard nodes still returns
degenerate rects. If future code (e.g., Phase 3.3b whitespace indicators, accessibility
hit testing) measures guard node positions, those measurements would be wrong.

#### Implementation Strategy for Bug 1

Implement both variants in separate branches for live evaluation:
1. Branch `fix/tab-cursor-guard-wrap` — Variant A (guard wrapping)
2. Branch `fix/tab-cursor-position-override` — Variant B (position override)

Both branches should also include the Bug 2 fix (`Math.round()`). Test both with
the same test suite and manual verification.

#### Implementation Progress (2026-02-19)

**Branch `fix/tab-cursor-guard-wrap` — IN PROGRESS:**
- [x] Created branch from `v25`
- [x] TabBlot constructor + `_wrapGuardNodes()` implemented
- [x] CSS replaced: `.ql-tab-guard` + `.ql-tab > span[contenteditable="false"]`
- [x] `Math.round(widthNeeded)` applied in `_updateTabWidths()`
- [x] Regression test: cursor visibility at every tab position — PASSES
- [x] Regression test: ruler marker alignment — PASSES (after ruler timing fix)
- [x] Ruler timing bug found + fixed: `_getRulerEditorOffset()` returned 0 before layout
- [x] Screenshot baseline updated (component height changed, no height constraint)
- [ ] Full test suite pass (running)
- [ ] Variant B branch

**Ruler alignment bug root cause (found during implementation):**
`_onTabStopsChanged()` calls `_addTabStopIcon()` → `_getRulerEditorOffset()` which uses
`getBoundingClientRect()`. But property observers fire BEFORE first layout, so all rects
are zero → offset = 0 → markers positioned without ruler-editor coordinate correction.
**Fix:** Wrap icon placement in `requestAnimationFrame()` to defer until after layout.
This is a pre-existing bug (present in original Phase 3.1c code, not caused by guard wrapping).

**All regression bugs RESOLVED (2026-02-20).** Squashed into single commit on `v25`.

| Bug | Fix | Commit |
|-----|-----|--------|
| 1. Cursor invisible | Guard wrapping in `<span class="ql-tab-guard">` min-width 2px | `82373142` |
| 2. Ruler offset | `Math.round(widthNeeded)` + `requestAnimationFrame()` | `82373142` |
| 3. ArrowUp/Down broken | `display: inline-block` + custom keyboard bindings via `getBounds()` | `82373142` |
| 4. Cursor stuck after last tab | Right guard `position: absolute; right: 0` + `position()` returns rightGuard | `82373142` |
| 5. ArrowUp/Down at boundaries | Jump to line start/end when no adjacent line | `82373142` |

**Final test results:** 109 pass, 20 fixme, 0 fail (tabstops 67+14fixme, readonly 18+1fixme, toolbar 24+5fixme).

### Bug 2: Tabs offset from ruler markers

**Symptoms:**
Tab stop positions (where cursor lands after tab) are visually shifted LEFT compared
to the tabstop indicators on the ruler. Offset is cumulative — each successive tab
drifts further left from its ruler marker.

**Root Cause (confirmed by both agents):**
`_updateTabWidths()` is iterative: each tab's `startPos` depends on
`getBoundingClientRect()` of the previous tab, which returns **fractional pixel values**.
Setting `tab.style.width` with fractional values causes Chrome's layout engine to
**pixel-snap** (round to device pixel boundaries). Error per tab: up to 0.5px on 1x display.
Errors accumulate: tab N has up to N × 0.5px drift.

Ruler markers use `tabStop.position` (integer values from Java API) positioned with a
single non-iterative calculation → no accumulation → they show correct positions.

**Fix (both agents agree):**

```javascript
// In _updateTabWidths(), change:
tab.style.width = widthNeeded + 'px';
// To:
tab.style.width = Math.round(widthNeeded) + 'px';
```

Integer pixel widths don't need pixel-snapping → no rounding error → no accumulation.
Max individual error: 0.5px (from Math.round), non-cumulative and imperceptible.

**Note:** `Math.round()` is applied to the FINAL `widthNeeded`, not to intermediate
measurements (e.g., `_measureContentWidth()` for R/M alignment). For right- and
center-aligned tabs, content width measurement also uses `getBoundingClientRect()` and
may have fractional values. The rounding happens on the combined result, so alignment
accuracy is ±0.5px — acceptable.

**Risk:** Very low. Affects only visual width by at most 0.5px per tab.

### File to modify (both bugs)

`/workspace/enhanced-rich-text-editor/src/main/resources/META-INF/resources/frontend/vcf-enhanced-rich-text-editor.js`

Sections (referenced by content, not line numbers — they shift with edits):
- `class TabBlot extends Embed` — constructor for Variant A, `position()` for Variant B
- `static get styles()` → `.ql-tab` CSS block — CSS rules for both variants
- `_updateTabWidths()` → `tab.style.width = ...` line — `Math.round()` for Bug 2

### Test coverage needed

**Automated (Playwright):**

Regression test for cursor visibility (already drafted in uncommitted tabstops.spec.ts):
- Insert N tabs, navigate with Home + ArrowRight, verify caret has non-zero height at every position
- Verify tab right edges align with ruler markers (within 1px tolerance)

Additional automated tests to add:
- Cursor visibility after `setContents()` reload (deserialized tabs, not just freshly inserted)
- Cursor after undo (insert tab → type text → Ctrl+Z back to tab → verify cursor visible)
- Mixed alignment (L/R/M) cumulative drift test — verify all 3 tab types align within 1px of markers

**Manual verification checklist:**
- Typing text before/after tabs
- Arrow key navigation through sequences of tabs
- Selection (Shift+ArrowRight) across tabs
- Copy/paste content containing tabs
- Undo/redo after tab insertion
- Soft-break tab copying still works
- **Cross-browser:** Chrome, Firefox, Safari (desktop). Bug is primarily Chrome/Blink but fix must be safe across all.
- **Headless vs. headed Chrome:** Headless uses software renderer and may not reproduce the
  exact caret behavior. Run headed Chrome for manual caret verification.
- **HiDPI display:** If available, test on 2x display (DPR affects sub-pixel rounding)

## Acceptance Criteria
- [x] TabBlot registered (Embed, `<span class="ql-tab">`)
- [x] Tab key inserts tab at cursor position
- [x] Iterative width calculation engine ported (~200 lines)
- [x] L/R/M alignment support
- [x] Java `TabStop` class + `setTabStops()`/`getTabStops()` API
- [x] Guard nodes handled (measure OUTER .ql-tab rect)
- [x] SoftBreakBlot registered (Embed, `<span class="ql-soft-break"><br></span>`)
- [x] Shift+Enter copies tabs up to cursor position (limited by tabstop count)
- [x] Horizontal ruler with clickable tabstop markers
- [x] `setNoRulers()` / `isNoRulers()` API
- [x] Playwright tests: 64 pass, 11 fixme
- [x] Sanitizer updated for ql-tab, ql-soft-break classes

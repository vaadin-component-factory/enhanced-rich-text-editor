# Phase 4.2: Tables Blot Migration

**Status:** NOT STARTED

## Objective

Migrate all table blots from Quill 1 / Parchment 2 to Quill 2 / Parchment 3, applying breaking changes and integrating with ERTE 2.

## Scope

### Blots to Migrate (5 total)

1. **TableContainer** (Block)
   - Top-level table wrapper
   - Manage table lifecycle
   - Handle table-level operations

2. **Table** (Block)
   - `<table>` element
   - Cell metadata encoding/decoding
   - Table ID management

3. **TableBody** (Block)
   - `<tbody>` element
   - Row container
   - Body-level operations

4. **TableRow** (Block)
   - `<tr>` element
   - Row ID management
   - Row operations (add/delete)

5. **TableCell** (Block)
   - `<td>` element
   - Cell metadata: rowspan, colspan, templateId, uniqueId
   - Cell format: `{tableId}|{rowId}|{cellId}|{rowspan}|{colspan}|{templateId}|{uniqueId}`

### Parchment 3 Breaking Changes (from SPIKE_RESULTS.md)

All 5 critical changes must be applied:

1. **`domNode` → `this.domNode`** in all methods
2. **`children` → `this.children`** for child access
3. **`statics` → `static`** class fields
4. **Remove `super.formats()`** — Parchment 3 throws error
5. **`allowedChildren` removed** — implement `insertBefore()` validation instead

### Additional V25 Changes

- Guard node awareness (Quill 2 embeds)
- **Sanitizer integration** (whitelist table elements/attributes)
  - ⚠️ **CRITICAL:** Tables use **template-based CSS classes and styles**
  - See Phase 3.6 findings: Statische Whitelists (wie in Core ERTE) funktionieren NICHT
  - **Required:** Template-basierte Validierung (Styles/Classes gegen Template-Definition prüfen)
  - Alternative: Pattern-based Whitelist (`table-template-*`, `cell-*`) + Template-Override
  - See SECURITY.md: "CSS Injection in Table Colors" & "TemplateParser CSS Values Not Validated"
- Quill 2 lifecycle hooks
- Delta format compatibility

## Success Criteria

- [ ] All 5 blots migrated to Parchment 3
- [ ] Table insertion works
- [ ] Cell metadata preserved
- [ ] Row/column operations functional
- [ ] **Sanitizer allows table markup WITH template-based classes/styles**
- [ ] Template-defined CSS properties validated (not blocked by static whitelist)
- [ ] SECURITY.md findings addressed (CSS injection, TemplateParser validation)
- [ ] No console errors
- [ ] Reviewed by fullstack-developer agent

## Technical Challenges

**Cell Metadata Format:**
```
{tableId}|{rowId}|{cellId}|{rowspan}|{colspan}|{templateId}|{uniqueId}
```
- Must survive HTML→Delta→HTML roundtrip
- Sanitizer must preserve `data-*` attributes
- Delta ops must encode/decode correctly

**Nested Block Structure:**
```
TableContainer > Table > TableBody > TableRow > TableCell > content
```
- Parchment 3 `insertBefore()` validation needed
- Child constraints enforcement
- Delete propagation

## Template-Based Sanitizer Strategy (CRITICAL)

**Problem:**
- Tables use **Style Templates** (V24 README: "predefine, modify, apply visual styles")
- Templates define **benutzerdefinierte CSS classes and styles** on cells
- Core ERTE sanitizer uses **statische Whitelists** → funktioniert NICHT für Tables

**Approaches:**

### Approach 1: Dynamic Template-Context Validation
```java
// Sanitizer receives template definitions
public String tablesSanitize(String html, List<TableTemplate> templates) {
    // Extract allowed classes/styles from templates
    Set<String> allowedClasses = templates.stream()
        .flatMap(t -> t.getClassNames().stream())
        .collect(Collectors.toSet());

    Set<String> allowedProperties = templates.stream()
        .flatMap(t -> t.getStyleProperties().keySet().stream())
        .collect(Collectors.toSet());

    // Validate HTML against template-derived whitelist
    return sanitizeWithContext(html, allowedClasses, allowedProperties);
}
```
**Pro:** Sicher, präzise
**Con:** Template-Objekte müssen beim Sanitize verfügbar sein

### Approach 2: Pattern-Based Whitelist + Post-Validation
```java
// Safelist allows pattern
.addAttributes("td", "class")  // permit class attribute
.addAttributes("td", "style")  // permit style attribute

// Post-filter validates patterns
private boolean isAllowedTableClass(String cls) {
    return cls.matches("table-template-\\d+")
        || cls.matches("cell-(header|body|footer)");
}

private boolean isAllowedTableStyle(String property, String value) {
    // Template-allowed properties
    if (!TEMPLATE_ALLOWED_PROPERTIES.contains(property)) return false;
    // Validate value (e.g., color must be hex/named, no url())
    return validateStyleValue(property, value);
}
```
**Pro:** Einfacher, keine Template-Context nötig
**Con:** Weniger sicher (muss alle möglichen Template-Patterns abdecken)

### Recommended: Hybrid Approach
1. **Pattern-based Whitelist** für class-Namen (`table-template-*`, `cell-*`)
2. **Property Whitelist** für erlaubte CSS Properties (color, background-color, border, etc.)
3. **Value Validation** für CSS Werte (block `url()`, `expression()`, validate colors)
4. **Template Registration** (optional): Templates registrieren beim Laden → tighter validation

**Security.md Compliance:**
- **CSS Injection in Table Colors:** Validate color values (hex, rgb, named colors only)
- **TemplateParser CSS Values:** Re-enable `isValidPropertyValue()` with allowlist

## Resources

- V24 table blots (`enhanced-rich-text-editor-tables/src/main/resources/META-INF/resources/frontend/`)
- **V24 TemplateParser** (`TemplateParser.java` — CSS validation logic to re-enable)
- `SPIKE_RESULTS.md` — Parchment 3 breaking changes
- V25 TabBlot, PlaceholderBlot — reference implementations
- **Phase 3.6 findings** — Learnings from Core ERTE sanitizer improvements
- Quill 2 / Parchment 3 docs (via WebSearch/WebFetch)

## Output

- `frontend/table-container-blot.js`
- `frontend/table-blot.js`
- `frontend/table-body-blot.js`
- `frontend/table-row-blot.js`
- `frontend/table-cell-blot.js`
- Quill.register() calls in main module

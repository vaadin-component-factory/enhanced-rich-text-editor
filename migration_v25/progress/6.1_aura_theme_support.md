# Phase 6.1: Aura Theme Support (Post-6.0.0)

**Status:** NOT STARTED
**Type:** Feature Addition
**Priority:** DEFERRED — Post-6.0.0 release
**Created:** 2026-02-21
**Updated:** 2026-02-25 (renumbered from Phase 5.1 → Phase 6.1)

> **Note:** ERTE 6.0.0 focuses on Lumo theme support only. Aura theme support is planned for a post-6.0.0 release.

**Prerequisite:** Phase 6 Spike (`6__spike.md`) must be completed first to validate Aura Style Proxy feasibility

---

## Scope

Add support for Vaadin's Aura theme alongside existing Lumo theme support. Currently ERTE is Lumo-only, which limits adoption in Aura-based projects.

---

## Background

### Current State (Post-Phase 3.4k)
- ERTE 6.0.0 will ship with **Phase 3.4k (Custom Properties)** implemented
- All ERTE-specific styles use `--vaadin-erte-*` custom properties (e.g., `--vaadin-erte-format-readonly-color`)
- These custom properties default to **Lumo-compatible values** in 6.0.0
- ERTE successfully inherits Lumo RTE styles via `lumoInjector` override
- Aura has NO equivalent injector mechanism (uses external CSS selectors instead)

### Theme Compatibility Challenge
When Aura theme is active:
- **ERTE custom properties** (`--vaadin-erte-*`) will still have Lumo-based defaults
- **Aura design tokens** may have different values than Lumo equivalents
- Without theme-aware defaults, ERTE features may look inconsistent with Aura's design language

### Analysis Documents
- **Technical:** `6.1__aura_theme_technical.md` (fullstack-developer)
- **Design:** `6.1__aura_theme_design.md` (ui-designer)

---

## Implementation Approach

### 1. Update ERTE Custom Properties for Theme-Aware Defaults

**Context:** Phase 3.4k (Custom Properties) will be implemented in ERTE 6.0.0 with Lumo-only defaults.

**Current state after Phase 3.4k (Lumo-only):**
```css
:host {
  /* ERTE custom properties with Lumo defaults */
  --vaadin-erte-format-readonly-color: var(--vaadin-text-color-secondary);
  --vaadin-erte-format-readonly-background: var(--vaadin-background-container);
  --vaadin-erte-format-readonly-border-color: var(--vaadin-border-color);
  /* ... more properties ... */
}

.ql-readonly {
  color: var(--vaadin-erte-format-readonly-color);
  background-color: var(--vaadin-erte-format-readonly-background);
  outline: 1px solid var(--vaadin-erte-format-readonly-border-color);
}
```

**Challenge:**
- Generic Vaadin tokens (`--vaadin-*`) work across themes
- BUT: Aura may need different defaults for optimal design language alignment
- Example: Aura uses different contrast levels, border styles, and spacing than Lumo

**Solution: Theme-Aware Custom Property Defaults**

Detect active theme and adjust ERTE custom property defaults accordingly:

```javascript
// In vcf-enhanced-rich-text-editor.js

static get styles() {
  return css`
    :host {
      /* Generic Vaadin fallbacks (work for both themes) */
      --vaadin-erte-format-readonly-color: var(--vaadin-text-color-secondary);
      --vaadin-erte-format-readonly-background: var(--vaadin-background-container);
      /* ... */
    }

    /* Aura-specific overrides (when Aura theme is active) */
    :host([theme~="aura"]) {
      /* Adjust defaults for Aura design language if needed */
      --vaadin-erte-format-readonly-background: var(--aura-surface-variant, var(--vaadin-background-container));
      /* Only override properties that need different values in Aura */
    }

    /* Component styles use custom properties */
    .ql-readonly {
      color: var(--vaadin-erte-format-readonly-color);
      background-color: var(--vaadin-erte-format-readonly-background);
      /* ... */
    }
  `;
}
```

**Alternative: Pure Generic Tokens**

If generic Vaadin tokens (`--vaadin-*`) provide sufficient compatibility, no theme-specific overrides needed:
```css
:host {
  /* These work for both Lumo and Aura */
  --vaadin-erte-format-readonly-color: var(--vaadin-text-color-secondary);
  --vaadin-erte-format-readonly-background: var(--vaadin-background-container);
}
```

**Decision Point:** After Aura integration testing, determine if theme-specific overrides are needed or if generic tokens suffice.

**Files to review:**
- `vcf-enhanced-rich-text-editor.js` - Review all `--vaadin-erte-*` custom property defaults
- Phase 3.4k property list - Audit each property for Aura compatibility

---

### 2. Implement Aura Style Proxy (Runtime Injection)

**Problem:**
- Aura's RTE-specific styles use selectors like `vaadin-rich-text-editor::part(toolbar)`
- These selectors don't match ERTE's `vcf-enhanced-rich-text-editor` tag
- Hardcoding Aura styles would break updatability (Vaadin updates → ERTE out of sync)

**Solution: Runtime Style Proxy**

Add method to ERTE that:
1. Scans all document stylesheets for `vaadin-rich-text-editor` rules
2. Clones them with `vcf-enhanced-rich-text-editor` selector
3. Injects as new `<style>` element into document head

**Implementation:**

```javascript
// In vcf-enhanced-rich-text-editor.js

/** @override */
connectedCallback() {
  super.connectedCallback();
  this._injectAuraStyleProxy();
}

/**
 * Dynamically injects cloned theme styles for ERTE (temporary solution).
 *
 * BACKGROUND: Aura theme (and potentially future themes) use external CSS
 * selectors like `vaadin-rich-text-editor::part(toolbar)` which don't match
 * ERTE's `vcf-enhanced-rich-text-editor` tag. This method scans document
 * stylesheets for vaadin-rich-text-editor rules and creates equivalent rules
 * for vcf-enhanced-rich-text-editor, ensuring ERTE receives all theme-specific
 * RTE styles without hardcoding them.
 *
 * TEMPORARY: This is a workaround until Vaadin provides a native theme
 * injection mechanism for custom RTE extensions (similar to LumoInjector).
 * If Vaadin adds native support (e.g., an "AuraInjector" or generic
 * "ThemeInjector" that works for all themes and allows tag name override),
 * this method should be removed and replaced with the official mechanism.
 *
 * REMOVAL CRITERIA:
 * - Vaadin introduces a theme-agnostic injector (like LumoInjector but for all themes)
 * - OR: Vaadin's Aura package explicitly includes vcf-enhanced-rich-text-editor selectors
 * - OR: Vaadin documents an official pattern for extending RTE with custom tags
 *
 * @private
 */
_injectAuraStyleProxy() {
  // Avoid duplicate injection
  if (document.querySelector('style[data-vcf-erte-theme-proxy]')) {
    return;
  }

  const rteRules = [];

  // Scan all stylesheets
  for (const sheet of document.styleSheets) {
    try {
      for (const rule of sheet.cssRules) {
        if (rule.cssText && rule.cssText.includes('vaadin-rich-text-editor')) {
          rteRules.push(rule.cssText);
        }
      }
    } catch (e) {
      // CORS-protected sheets (CDN) - skip silently
      console.debug('ERTE: Skipping stylesheet (CORS):', sheet.href, e);
    }
  }

  if (rteRules.length === 0) {
    return; // No RTE-specific theme styles found
  }

  // Clone rules with ERTE tag name
  const proxyStyles = rteRules.map(cssText =>
    cssText.replace(/vaadin-rich-text-editor/g, 'vcf-enhanced-rich-text-editor')
  );

  // Inject into document
  const styleEl = document.createElement('style');
  styleEl.setAttribute('data-vcf-erte-theme-proxy', '');
  styleEl.textContent = `/* ERTE Theme Style Proxy (auto-generated) */\n${proxyStyles.join('\n')}`;
  document.head.appendChild(styleEl);

  console.debug(`ERTE: Injected ${rteRules.length} theme style rules`);
}
```

**Advantages:**
- ✅ **Updatability:** ERTE automatically gets Aura updates (on page reload)
- ✅ **Theme-agnostic:** Works for Lumo, Aura, and future themes
- ✅ **No hardcopy:** ERTE code stays clean

**Edge cases handled:**
- CORS-protected stylesheets (try-catch, skip silently)
- Timing (themes load before components in Vaadin)
- Duplicate injection (guard with data attribute)

---

## Design Consideration: Generic Theme Injector

### Current Situation

**Two separate theme injection mechanisms:**
1. **LumoInjector** (existing in Vaadin 25)
   - ERTE overrides `lumoInjector` getter to return `{is: 'vaadin-rich-text-editor'}`
   - This makes ERTE inherit Lumo's RTE styles

2. **AuraInjector** (planned: style proxy above)
   - Runtime scanning of stylesheets
   - Cloning rules with ERTE tag name
   - Injecting as `<style>` element

**Problem:** Both mechanisms do essentially the same thing (inject theme-specific RTE styles for ERTE), just using different technical approaches. Having two separate implementations creates:
- Code duplication
- Maintenance overhead
- Different behavior patterns for different themes

### Alternative: Generic VaadinThemeInjector

**Proposal:** Create a unified `VaadinThemeInjector` that encapsulates both mechanisms:

```javascript
/**
 * Generic theme injection mechanism for ERTE.
 * Handles both Lumo (via injector override) and Aura/other themes (via style proxy).
 */
class VaadinThemeInjector {
  constructor(component) {
    this.component = component;
  }

  /**
   * Returns theme-specific injector config (for Lumo-style injection)
   */
  getInjectorConfig() {
    return { is: 'vaadin-rich-text-editor' };
  }

  /**
   * Injects theme styles via runtime proxy (for Aura-style injection)
   */
  injectStyleProxy() {
    // Implementation from _injectAuraStyleProxy() above
  }

  /**
   * Initialize theme injection (called from connectedCallback)
   */
  init() {
    // Try injector-based approach first (Lumo)
    // Fall back to style proxy (Aura, others)
    this.injectStyleProxy();
  }
}
```

**Usage in ERTE:**
```javascript
class VcfEnhancedRichTextEditor extends RteBase {
  constructor() {
    super();
    this._themeInjector = new VaadinThemeInjector(this);
  }

  /** @override */
  static get lumoInjector() {
    return this._themeInjector?.getInjectorConfig() || { is: 'vaadin-rich-text-editor' };
  }

  /** @override */
  connectedCallback() {
    super.connectedCallback();
    this._themeInjector?.init();
  }
}
```

### Advantages

✅ **Single responsibility:** One class handles all theme injection
✅ **Consistency:** Same behavior pattern for all themes
✅ **Extensibility:** Easy to add support for future themes (Material, custom themes)
✅ **Maintainability:** Changes to theme injection logic happen in one place
✅ **Cleaner ERTE code:** Component delegates theme injection to specialized class

### Disadvantages

⚠️ **Added complexity:** Introduces new abstraction layer
⚠️ **Overhead:** Extra object creation (negligible performance impact)
⚠️ **Testing:** Need to test injector class separately

### Recommendation

**IMPORTANT:** This design consideration should be evaluated during Phase 6.1 planning:

1. **If Lumo + Aura are the ONLY themes ERTE will support:**
   - Current approach (override `lumoInjector` + add style proxy) is simpler
   - No need for abstraction layer

2. **If future themes are expected (Material, custom themes):**
   - Generic `VaadinThemeInjector` makes sense
   - Invest in abstraction now to save refactoring later

3. **If Vaadin plans to provide official theme injection API:**
   - Wait for official solution, don't over-engineer
   - Use temporary style proxy for now

**Decision point:** Include this evaluation in the planning phase before implementation begins.

---

### Source Code Analysis (v25.1.0-alpha8)

**Date checked:** 2026-02-22
**Version:** [v25.1.0-alpha8](https://github.com/vaadin/web-components/tree/v25.1.0-alpha8)

**Findings:**

✅ **LumoInjector exists** (confirmed in `vaadin-rich-text-editor.js`):
```javascript
static get lumoInjector() {
  return { ...super.lumoInjector, includeBaseStyles: true };
}
```

❌ **No AuraInjector found** - Aura theme does not have equivalent injection mechanism

❌ **No generic ThemeInjector found** - System is Lumo-specific:
- `LumoInjectionMixin` from `@vaadin/vaadin-themable-mixin/lumo-injection-mixin.js`
- Hardcoded `new LumoInjector(root)` - no theme selection parameter
- No abstraction layer for alternative themes

**Structure:**
- RTE package: Only base styles (`src/styles/vaadin-rich-text-editor-base-styles.js`)
- No Lumo/Aura theme files within RTE package itself
- Theme styles managed externally via injection mixin

**Conclusion for Point 3:**
Vaadin **does not** appear to be planning a generic theme injection API in the v25.1 timeline. The LumoInjector remains Lumo-specific with no visible roadmap for abstraction. Therefore:
- **Do not wait** for official multi-theme injection API
- **Implement style proxy** as planned (it's the only viable option for Aura)
- **Consider generic VaadinThemeInjector** if future theme support is desired (Material, custom themes)

---

## Tasks

### Step 1: Audit ERTE Custom Properties for Aura Compatibility
- [ ] Review Phase 3.4k custom property list (all `--vaadin-erte-*` properties)
- [ ] Test each property's default value under Aura theme (visual compatibility check)
- [ ] Identify properties that need Aura-specific overrides (if any)
- [ ] Document theme-specific adjustments needed
- [ ] Update custom property definitions with `:host([theme~="aura"])` overrides (if needed)
- [ ] Verify all ERTE features look consistent with Aura design language

### Step 2: Aura Style Proxy
- [ ] Add `_injectAuraStyleProxy()` method to ERTE
- [ ] Call from `connectedCallback()`
- [ ] Add duplicate injection guard
- [ ] Add debug logging (console.debug)
- [ ] Handle CORS errors gracefully

### Step 3: Testing
- [ ] Manual test: Create demo view with Aura theme
- [ ] Verify all features work visually:
  - Readonly sections (background, outline, text color)
  - Placeholders (accent-based background)
  - Whitespace indicators (proper colors in light/dark mode)
  - Tab stops
  - Toolbar styling
- [ ] Test Lumo theme (ensure no regression)
- [ ] Test dark mode for both themes
- [ ] Verify WCAG AA contrast ratios (use browser dev tools)

### Step 4: Documentation
- [ ] Update README.md: Add Aura to supported themes list
- [ ] Update CONFIGURATION.md: Add Aura-specific configuration notes (if any)
- [ ] Update UPGRADE_GUIDE.md: Note that Aura support is planned for post-6.0.0 releases
- [ ] Add theme switching example (if relevant)

---

## Browser Compatibility

**`color-mix()` support:**
- Safari: 16.4+ (March 2023)
- Chrome/Edge: 111+ (March 2023)
- Firefox: 113+ (May 2023)

**Fallback strategy:**
If supporting older browsers is needed, use:
```css
background-color: var(--vaadin-primary-color-10pct,
  color-mix(in srgb, var(--vaadin-primary-color) 10%, transparent));
```

---

## Known Limitations

1. **Style Proxy Timing:** Proxy injection happens once at component connection. If theme stylesheets are loaded dynamically AFTER ERTE, those styles won't be proxied. (Very rare in production Vaadin apps)

2. **CORS:** Stylesheets from external domains (CDN) cannot be read. These will be skipped silently. (Uncommon in Vaadin setups)

3. **No SSR/Pre-render Support:** Style proxy runs in browser only. Server-side rendering won't include proxied styles. (Not relevant for Vaadin Flow apps)

---

## Success Criteria

- [ ] All ERTE custom properties (Phase 3.4k) reviewed for Aura compatibility
- [ ] Theme-specific overrides added (if needed) for properties that differ between Lumo and Aura
- [ ] Aura style proxy implemented and tested
- [ ] ERTE works correctly under Aura theme:
  - All features visible and functional
  - Proper colors in light and dark mode
  - WCAG AA contrast maintained
  - Design language consistent with Aura (not Lumo-looking-in-Aura)
- [ ] No regressions under Lumo theme
- [ ] Custom properties work correctly in both themes
- [ ] Documentation updated (custom properties list includes Aura-specific notes)
- [ ] Manual testing complete (both themes, light/dark modes)
- [ ] Progress file updated to COMPLETE
- [ ] Commit created: "Add Aura theme support with runtime style proxy (Phase 6.1)"

---

## Estimated Effort

**Total: 5-8 hours**
- Custom properties audit: 1-2 hours (review Phase 3.4k properties under Aura)
- Theme-specific overrides: 1-2 hours (if needed)
- Aura style proxy: 2-3 hours (implementation + edge cases)
- Testing (manual, both themes, light/dark): 1-2 hours
- Documentation: 30-60 minutes (update custom properties list with Aura notes)

---

## Dependencies

- **Prerequisite:** Phase 3.4k (Custom Properties for ERTE Styles) must be complete
- **Prerequisite:** Phase 6 Spike (`6__spike.md`) validates style proxy approach
- Should be done BEFORE Phase 6 documentation updates
- Independent of Phase 4 (Tables) — can be done before or after
- If Phase 4.6 (Tables Custom Properties) is complete, those should also be audited for Aura compatibility
